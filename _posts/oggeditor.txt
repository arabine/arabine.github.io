(((Magazine : Coder)))
(((Rubrique : Programmation)))
(((Sous Rubrique : Pro)))

(((titre))) Un éditeur de commentaires pour fichiers Ogg

(((chapeau)))
Le format Ogg est le pendant libre du format de compression audio MP3. Nous allons nous intéresser à la structure de ce  format alternatif en programmant un éditeur de commentaires en C++. Nous utiliserons la librairie Qt pour créer une interface graphique sans peine et rendra ainsi notre utilitaire portable sur différents systèmes d'exploitation.

(((texte)))
Le MP3 est sans conteste le format le plus populaire pour le stockage de fichiers musicaux. Il possède de nombreux concurrents comme le WMA, l'AAC, le MPC ... ou l'Ogg Vorbis, format qui va nous intéresser dans cet article. Le Ogg est en fait un ensemble de standards multimédias ouverts promus par la fondation Xiph.org. Les projets en cours sont le  Ogg Vorbis (compression audio avec perte), Ogg Theora (compression vidéo), FLAC (compression audio sans perte) et le Speex (compression de la parole). La grande force du format Ogg Vorbis vient de son absence totale de licences propriétaires comme c'est le cas avec le MP3 qui appartient à Thomson/Fraunhofer. De plus, tous les outils et les algorithmes de compression/décompression sont disponibles en Open Source, ce qui permet à tout un chacun de créer ses propres logiciels ou lecteurs portables sans payer de royalties, contrairement au MP3. Le format Ogg Vorbis est assez récent, la version 1.0 ne datant que de juillet 2002. Quoiqu'il en soit, il est déjà assez mature pour être généralement meilleur que le MP3 en terme de rapport qualité audio/taille du fichier. Toutes ces qualités permettent à L'Ogg Vorbis se tailler une bonne place dans la jungle des formats audio et il n'est pas rare de le voir utilisé à la place du MP3 dans certains logiciels commerciaux comme les jeux vidéo par exemple. A l'instar des Tags du MP3, le format Ogg Vorbis est capable de stocker des commentaires très utiles pour gérer efficacement sa bibilothèque audio. Nous allons donc construire une application d'édition de ces commentaires, ce qui nous donnera l'occasion d'en apprendre un peu plus sur la structure de ce format.

(((inter))) Organisation du fichier
Parler du format Ogg seul est un abu de langage car ce nom correspond en fait à la couche physique (ou de transport) du format Ogg/Vorbis. La méthode de compression audio proprement dite s'appelle quant à elle Vorbis. La norme Ogg est  potentiellement capable d'encapsuler n'importe quelle information et sa structure n'est pas particulièrement liée au format Vorbis. Regardons un peu plus près l'organisation de cette couche physique. Un fichier Ogg est constitué d'une séquence de pages concaténées de tailles variables et disposant chacune d'un en-tête d'identification. Chaque page a une taille maximale de 65307 octets mais le plus souvent la taille est comprise entre 4 et 8 ko pour des raisons de performances. L'en-tête possède de nombreuses informations servant à lire les données incluses dans la page , détecter les erreurs et situer la page dans la séquence physique. Dans le format Ogg les données, qui suivent immédiatement l'en-tête, sont regroupées en paquets. Un paquet représente un groupe de données bien précis : on trouvera par exemple un paquet d'identification, un paquet de commentaires ou un paquet d'échantillons audio. Lors de l'encodage, ces paquets bruts seront rangés en segments, chacun ayant une taille de 255 octets, sauf le dernier segment d'un paquet qui aura une taille strictement inférieure à 255 octets. Cette méthode permet donc de détecter la fin d'un paquet de données ce qui facilite le décodage d'un flux Ogg. Un paquet peut éventuellement s'étaler sur plusieurs pages consécutives si les données sont importantes, comme cela peut l'être avec les commentaires. On appellera la première page d'un flux Ogg par "BOS"  (Beginning Of Stream) et la dernière page par "EOS" (End Of Stream). Les pages situées entre les deux auront soit le statut de nouveau paquet (“fresh packet”) soit le statut de paquet faisant suite à la page précédente. Pour vous faciliter la tâche, nous avons regroupé toutes ces informations au sein de tableaux situées sur ces pages. Vous y  trouverez la taille de chaque donnée ainsi que le décalage (offset) par rapport au début des en-têtes pour situer la donnée. 

(((inter))) Lecture et validation du fichier Ogg
Pour implémenter la lecture des commentaires, nous allons créer une classe C++ mais sans utiliser les fonctionnalités de la librairie Qt. En effet, cette librairie n'offre pas seulement des composants pour fabriquer des interfaces graphiques (les Widgets) mais fournit également de nombreuses classes utiles pour gérer le réseau, les fichiers, les chaînes de caractères ou encore les bases de données. Nous aurions pu utiliser ces fonctionnalités mais notre classe OggFile aurait été trop liée à la librairie Qt. Notre classe pourra donc être utilisée indépendamment de toute librairie graphique. La première étape est de charger le fichier Ogg en mémoire et de lire le flux page par page. Le tableau ci-contre montre que chaque page commence par la chaîne de caractères "OggS", cette indication nous donnera donc le point de départ de la phase de contrôle. Cette phase sert à contrôler si la page Ogg correspond au standard et ne contient pas d'erreurs. Il faut donc vérifier la version du format Ogg, le type de page, la position et le CRC. Attardons nous plus particulièrement sur cette dernière notion. Un CRC (cyclic redundancy check) est une méthode mathématique pour détecter l'apparition d'éventuelles erreurs dans des données. On entend également souvent parler de checksum mais c'est une erreur car  le checksum repose sur un principe de calcul différent et est beaucoup moins performant que le CRC. Le checksum étant, comme son nom l'indique, une simple somme, il n'est pas capable de détecter certaines erreurs comme un changement dans l'ordre des données. Les CRC sont calculés avant puis après une transmission ou duplication et sont comparés pour confirmer qu'ils sont identiques. L'opération mathématique essentielle derrière le CRC est la division binaire, le reste représentant le CRC. La fonction de calcul, très courte, est la suivante :

(((listing)))
unsigned long crc_normal(unsigned char *blk_adr, unsigned long blk_len)
{
  unsigned long crc = INIT;
  while (blk_len--)
      crc = crctable[((crc>>24) ^ *blk_adr++) & 0xFFL] ^ (crc << 8);
  return crc ^ XOROT;
}

(((texte)))
Cet algorithme est une version optimisée du calcul théorique car il utilise un tableau de valeurs pré-calculées. Ainsi, le calcul ne se fait plus bit après bit mais octet après octet. La génération de cette table peut être faite simplement en utilisant le code source fourni sur le CD du magazine. La fonction ci-dessous nécessite deux arguments : un pointeur vers une table d'octets et la taille de cette table. Dans la pratique, cette table sera le contenu de la page courante, mais attention : l'emplacement du code CRC doit être mis à zéro avant d'appeler cette fonction. Le calcul du CRC nécessite de connaître quelques paramètres, dont le plus important est le polynôme utilisé pour la division. La documentation officielle Ogg informe que  le polynome doit être 0x04C11DB7, soit le même code utilisé dans l'Ethernet, le format ZIP ou encore le PNG. Pour plus d'informations du la théorie du CRC, reportez vous au document fourni sur le CD. Le dernier élément important de l'en-tête Ogg est la table des segments, c'est à dire la "carte" des données qui vont suivre. Comme nous pouvons le voir sur le tableau ci-contre, nous trouvons le nombre de segments dans la page suivit de la taille de chaque segments. Le plus souvent, c'est le cas avec l'encodeur officiel, nous trouvons dix-sept segments. Cette quantité n'est pas obligatoire mais elle permet d'avoir une page de 4ko comme nous le conseille la norme. Voici quelques formules qui vous aideront à calculer certains paramètres du flux Ogg :

(((listing)))
Taille totale d'un en-tête Ogg (en octets) :
header_size = number_page_segments + 27

Taille totale de la page (en octets) : 
page_size = header_size + sum(lacing_values: 1..number_page_segments)

(((inter))) Organisation et encapsulation de Vorbis
Attaquons nous maintenant au format Vorbis. Il est composé de trois paquets principaux, en plus du paquet de données contenant les échantillons audio compressés. Le premier paquet est celui d'identification et contient les caractéristiques du fichier audio : nombre de voies, fréquence d'échantillonnage, débit, etc. Ce paquet est de taille fixe et se situe obligatoirement dans la page BOS dans le flux Ogg. La première page d'un fichier Ogg sera donc toujours longue de 58 octets. Voici le décompte : 28 octets pour l'en-tête de la page Ogg et 30 octets pour le paquet d'identification du flux Vorbis. Référez vous aux tableaux sur ces pages pour calculer vous même. Ces tableaux indiquent où trouver les informations du fichier audio, comme la version, le nombre de voies ou la fréquence d'échantillonnage. Le deuxième paquet nous intéresse particulièrement car il contient les commentaires. Il suit le paquet d'identification, commence toujours sur la deuxième page et s'étend sur une ou plusieurs pages, selon la taille des commentaires. Enfin, on trouve le paquet "setup" contenant toutes les informations nécessaires au décodage des données compressées. Ce paquet ne nous servira pas ici. Chaque paquet Vorbis est identifié par un numéro suivi par la chaîne de caractères "vorbis" et est donc relativement facile à détecter.

(((inter))) Lecture des commentaires
Nous possédons maintenant suffisamment d'informations sur le format Ogg/Vorbis pour créer un visualiseur de commentaires. Les couches basses de décodage sont regroupées au sein de la classe OggFile. Les membres de cette classe contiennent les informations du fichier Ogg, les commentaires et quelques variables propres à la procédure de décodage. La procédure générale nous est donnée par le format lui même : il faut dans un premier temps repérer une page Ogg, décoder l'en-tête, calculer le CRC pour vérifier l'absence d'erreurs puis appeler la procédure de décodage du format Vorbis. À partir de là, on recommence une nouvelle étape de décodage des en-têtes Vorbis. La seule grosse difficulté de l'algorithme vient de la longueur variable des commentaires : ils peuvent très bien utiliser plusieurs pages, ce qui complique un peu la lecture. La documentation officielle sur le format Vorbis préconise une structure de commentaires de la façon suivante :

(((listing)))
LABEL=commentaire
exemple : TITLE=Troll farceur

(((texte)))
Il existe d'autres étiquettes qu'il est souhaitable de respecter, mais ce c'est pas obligatoire. L'encodage des caractères des commentaires est en UTF-8 ce qui permet d'utiliser toutes les langues possibles. Un bon lecteur devrait supporter cette fonctionnalité. L'apparence de l'interface sera entièrement copiée sur l'éditeur de commentaires intégré au célèbre  Winamp. Qt Designer permet de réaliser rapidement une interface en y plaçant des Widgets, à la manière de Visual Basic. L'interface est sauvegardée sous la forme d'un fichier XML et servira à générer du code source C++ durant la phase de compilation. Il ne faut surtout pas ajouter son propre code dans ces fichiers générés car ils sont susceptibles d'être écrasés lors d'une prochaine compilation. À la place, il faut créer une nouvelle classe, appelée "OggEditorDialog" dans notre projet, qui héritera des fonctionnalités de la classe générée nommée "MainForm" représentant l'interface :

(((listing)))
class OggEditorDialog : public MainForm
{
  Q_OBJECT
  // etc.

(((texte)))
Le reste du code se charge de régler les interactions avec l'utilisateur et les appels à la classe OggLib, ainsi qu'à formater les données affichées.

(((inter))) Ecriture de commentaires
Si la lecture est relativement simple, l'écriture est quant à elle beaucoup plus complexe. En effet, les commentaires se situent au sein même du flux Ogg ce qui ne simplifie pas les choses, d'autant plus que la taille théorique des commentaires n'est pas limitée. Ainsi, il est nécessaire de ré-écrire toutes les pages pour mettre à jour certaines informations situées dans l'en-tête Ogg, comme la position de la page par exemple. Malgré toutes ces difficultés, il est toujours possible d'écrire son propre algorithme d'écriture mais nous allons procéder autrement : nous allons utiliser l'intérêt majeur du format Ogg : celui d'être un programme Open Source. En cherchant un peu dans les codes sources des outils officiels nous trouvons un utilitaire de gestion des commentaires écrit en langage C appelé vorbiscomment. Nous allons donc reprendre une très grande partie de ce code en remplacement de notre classe précédente. Cependant, nous garderons les mêmes noms de classe, accesseurs et mutateurs afin de ne modifier que le corps des méthodes : ainsi, le code source Qt restera inchangé. Il sera également nécessaire d'ajouter les librairies Ogg à notre application afin d'utiliser les fonctionnalités de l'API, c'est à dire le corps des fonctions que nous allons appeler. Reportez vous aux encarts pour connaître la procédure d'installation sous Windows et Linux. Le code source de l'API est intégralement en langage C, et les informations utiles se trouvent dans quelques structures, le tout est de savoir lesquelles. La première chose à faire est d'étudier le programme principal situé dans le fichier vcomment.c. On retrouve certaines variables de la structure param_t, nous allons donc les placer dans notre classe OggLib en tant que membres privés. Les fonctions restantes sont assez parlantes, nous y trouvons une procédure de lecture et d'écriture des commentaires. Laissons tomber le reste du code servant à la gestion de la ligne de commande et à l'affichage. Les fichiers vcedit.h et vcedit.c permettent d'accéder facilement aux informations contenues dans le fichier musical. La structure principale se nomme vcedit_state et contient tout ce qu'il faut pour réaliser notre logiciel. Nous allons donc créer une variable de ce type, et la remplir par le contenu d'un fichier Ogg :

(((listing)))
vcedit_state *state;
FILE *in;
in = fopen("donjon-trollfarceur.ogg", "rb");
state = vcedit_new_state();
vcedit_open(state, in);
// La structure 'state' est maintenant remplie...

(((texte)))
La sous structure vorbis_info permet de récupérer les informations générales du fichier comme la version de Vorbis, le nombre de voies ou la fréquence d'échantillonnage. La structure ogg_stream_state permettra quant à elle d'obtenir toutes les informations sur le flux Ogg, le numéro de série par exemple. Enfin, la structure vorbis_comment permettra comme son nom l'indique d'accéder aux commentaires. Ces structures sont fournies avec des fonctions toutes faites capables de gérer efficacement le contenu de ces structures. Par exemple, la fonction vorbis_comment_add_tag() permet d'ajouter un commentaire à un fichier Ogg sans se soucier des allocations mémoires et de la structure du fichier Ogg. Nous vous laissons regarder le code source plus en détail, celui-ci étant disponible sur le CD du magazine.

(((inter))) Conclusion
Dans un premier temps, nous avons vu comment accéder aux commentaires d'un fichier Ogg en étudiant sa structure. Dans un second temps, nous avons profité du code open source source de la fondation Xiph.org afin d'ajouter facilement les fonctionnalités en lecture et en écriture. Enfin, grâce à l'utilisation de la librairie Qt, nous avons créé très rapidement une interface utilisateur. Qui plus est, notre programmes est  également portable sur d'autres systèmes d'exploitation. Nous voyons que le programmeur dispose de nombreux outils pour faciliter sa tache, n'hésitez donc pas à vous en servir dans vos applications !

(((signature)))
Anthony Rabine

(((images)))
PP_editeurogg_01.jpg : Toutes les pages d'un flux Ogg possèdent un en-tête et des segments.
PP_editeurogg_02.jpg : Les commentaires se situent à partir de la deuxième page du flux Ogg.
PP_editeurogg_03.jpg : Qt Designer permet de créer très rapidement des interfaces graphiques.
PP_editeurogg_04.jpg : Les données d'un même type sont rangées en segments au sein d'un flux Ogg.
PP_editeurogg_05.jpg : L'éditeur intégré à Winamp a inspiré l'interface de notre programme.
PP_editeurogg_06.jpg : Ajoutez au projet les librairies nécessaires à la compilation.
PP_editeurogg_07.jpg : Pour compiler, il faut spécifier l'emplacement des librairies Ogg/Vorbis.
PP_editeurogg_08.jpg : Sous Linux, les sources sont ajoutées à un projet Qt Designer.
PP_editeurogg_09.jpg : Notre éditeur de commentaires pour fichiers Ogg en pleine action.
PP_editeurogg_10.jpg : Une simple recompilation et nous retrouvons OggEditor sous Linux !

(((encadré)))
(((légende du tableau : Éléments de l'en-tête d'une page.)))
Offset
Taille (octets)
Description
0
4
Contient la chaîne "OggS"
4
1
Version du format Ogg (toujours zéro pour la version 1
5
1
Type de page
6
8
Position
14
4
Numéro de série
18
4
Place dans la séquence
22
4
Checksum
26
1
Nombre de segments
27
1 ou plus
Taille de chaque segment (un octet par segment)
(((fin encadré)))

(((encadré)))
(((légende du tableau : Éléments du paquet Identification Vorbis.)))
Offset
Taille (octets)
Description
0
1
Type du paquet (doit être égal à 1)
1
6
Chaîne "vorbis"
7
4
Version vorbis (0 pour Vorbis version 1)
11
1
Nombre de voies
12
4
Fréquence d'échantillonnage
16
4
Débit maximum
20
4
Débit nominal
24
4
Débit minimum
28
1
Blocksize 0 et 1
29
1
Fin du paquet : doit être égal à 1
(((encadré)))

(((encadré)))
(((légende du tableau : Éléments du paquet Commentaire Vorbis.)))
Offset
Taille (octets)
Description
0
1
Type d'en-tête (toujours 3)
1
6
Chaîne "vorbis"
7
4
Taille du nom du fournisseur (A octets)
11
A
Nom du fournisseur
-
4
Nombre de commentaires
-
4
Taille du commentaire 1 (B octets)
-
B
Commentaire 1
-
4
Taille du commentaire 2 (C octets)

C
Commentaire 2

...
...

1
Fin du paquet : doit être égal à 1
(((fin encadré)))

(((encart)))
(((titre))) Liens
http://www.xiph.org/ogg/vorbis
http://www.vorbis.com
http://www.trolltech.com

(((encart)))
(((titre))) Bien configurer Visual C++
La première chose à faire est de compiler les librairies Ogg et Vorbis. Ces librairies sont disponibles sur le CD du magazine et se nomment respectivement libogg-1.0.zip et libvorbis-1.0.zip. Décompresser ces archives et utiliser les projets Visual C++ pour les compiler, en commençant par la librairie Ogg. Les projets se comment ogg_static et vorbis_static et devraient générer sans erreurs deux librairies du même nom avec l'extension .lib. Il s'agit maintenant d'ajouter ces librairies à votre projet Visual C++, en allant dans le menu Project / Settings / onglet Link. Ajouter manuellement les deux librairies vorbis_static.lib ogg_static.lib à la fin de la ligne Object/library modules. Enfin, le dernier paramétrage consiste à spécifier les répertoires où le compilateur pourra trouver ces librairies et les fichiers d'en-têtes correspondants. Cela se paramètre dans le menu Tools / Options / onglet Directories.

(((encart)))
(((titre))) Compilation sous Linux
La méthode générale est similaire à la configuration sous Windows. Dans un premier temps, il faut décompresser les archives libogg-1.0.zip et libvorbis-1.0.zip. La compilation se déroule comme à l'accoutumée sous Linux, c'est à dire par la séquence ./configure, make puis make intall, en root et en commençant par compiler la librairie Ogg. Les en-têtes sont alors copiés dans le répertoire /usr/include et les librairies dans /usr/local/lib. Lancer ensuite Qdesigner, ajouter le fichier UI  et les fichiers sources, exceptés les codes sources générés durant la compilation (les moc et le code de l'interface graphique). Sauver le projet (fichier .pro) et générer le Makefile à l'aide de la commande : qmake -o Makefile oggeditor.pro. Avant de lancer la compilation, éditer le Makefile et rajouter les librairies Ogg et Vorbis, en ajoutant -logg -lvorbis au bon endroit. Enfin, lancer la compilation en tapant make. Le projet Linux est disponible sur le CD.


