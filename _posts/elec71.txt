(((Magazine : PC Team 71)))
(((Rubrique : Team pratik)))
(((Sous Rubrique : électronique)))

(((titre))) Le PC à l’heure atomique

(((chapo)))
Nous allons faire connaissance ce mois-ci avec un petit module, le DCF-77, qui nous donnera l’heure exacte avec une précision atomique. Encore une fois, nous allons voir qu’il est possible de s’amuser avec peu d’électronique…

(((texte)))
Le DCF-77 est un module récepteur radio donnant la possibilité de capter l’heure émise par un émetteur situé en Allemagne. Pour la petite histoire, il s’agit d’un centre scientifique situé à Braunscweig qui possède une horloge atomique au Césium dont la précision est redoutable : 1 seconde d’écart sur 1 million d’années ; voilà qui nous donne le temps de voir venir les choses. L’émetteur, situé à Frankfort, transmet ensuite cette information via les ondes radios sur une porteuse à 77,5 KHz.. La portée de cette onde est de 1500 Km, ce qui nous permet de la capter également sur presque tout le territoire français. Le petit module présenté ici s’occupe donc de capter ce signale et de le mettre en forme pour qu’il puisse être facilement traité par un microprocesseur par exemple. Il se compose en une barre de ferrite, réglée pour capter les ondes radios à 77,5 KHz., et d’un petit circuit électronique nous fournissant le signal présenté ci-contre, à condition qu’il eût été convenablement alimenté bien sûr. Ce module est présent dans beaucoup d’horloges murales, de réveils et même des montres, ce qui est très pratique car vous n’avez plus à régler l’heure, tout se fait automatiquement. Le module présenté ici peut se trouver assez facilement, dans toute bonne boutique d’électronique qui se respecte. Notre exemplaire a par exemple été acheté chez Selectronic qui fournit avec une petite documentation fort bien réalisée (elle est fournie sur le CD Pro).

(((inter))) Le signal
Intéressons plus précisément au signal fournit par ce module. Il se présente sous la forme d’une trame de 59 bits émis toutes les secondes. Le soixantième bit de la trame n’est pas émit, il y a donc un ‘trou’ de deux secondes. Cet espace va nous être salvateur car c'est lui qui indique le commencement de la trame. L'initialisation d'un programme gérant le DCF-77 durera donc au moins 2 minutes. Cette trame contient les informations (codées en BCD) sur l’heure courante, les minutes, le jour calendaire, le mois, l’année ainsi que les changements d’heure pour l’été et l’hiver. Bref, nous avons tout ce qu’il faut pour réaliser notre petite horloge de PC. Il est possible de concevoir un système autonome qui remet le PC à l'heure par exemple. Le codage des informations de la trame est un peu particulier : en effet, nous communiquons avec le module par un bus de données de fil. C’est un mode de transmission assez courant, qui permet d’économiser de la place. Seulement, le problème est qu’aucune horloge ne cadence le flux de transmission, pour déterminer à quel instant un '1' ou un '0' a été transmis. Le protocole de bus un fil est le suivant : toute donnée est valide sur un état haut, et le temps que dure cet état différencie un ‘1’ d’un ‘0’. L’illustration ci-contre montre un exemple avec deux bits. La seule difficulté va être de disposer d'un timer relativement précis. Le tableau ci-contre regroupe tous les bits de la trame. Les informations sur plusieurs bits sont transmises par le bit de poids faible en premier. Le codage de ces informations est en BCD (Binaire Codage Décimal), nous vous renvoyons à l'encadré pour un petit rappel de ce codage.

(((inter))) Le montage
Le montage est relativement simple à faire. Peu de composants, et ceux-ci sont très courants, vous n’aurez donc pas de problèmes pour vous approvisionner. Là encore, plusieurs solutions s'offrent à nous. Il est possible d'utiliser à loisir le port série ou le port parallèle. L’intérêt d'un montage basé sur le port série est qu'il est alors possible de se passer d'une alimentation externe, le module étant alimenté via les broches du port. Nous rappelons que celui-ci fournit assez de courant pour alimenter un petit montage externe. Le schéma de principe représenté ci-contre montre cette alimentation ; celle-ci repose une fois de plus sur l'inévitable 7805, un régulateur de tension. En effet, les broches du port série utilisent une gamme de tension comprise entre –12V et +12V, il faut donc abaisser cette tension pour alimenter le DCF-77.comme il se doit, c'est à dire 5V. En ce qui concerne le port parallèle, il convient de vérifier si le port est capable de fournir assez de courant pour alimenter le module. Dans le cas contraire, il faut se résoudre à utiliser une alimentation externe (celle du PC ou d'une pile par exemple). Quelque soit votre choix, utilisez au moins une broche en entrée qui servira à recevoir le signal. En ce qui concerne le module proprement dit, il possède plusieurs bornes : il y a l'alimentation (borne positive et la masse), le signal de sortie et la mise en veille. Reportez vous à la documentation technique selon le module utilisé. Faites attention également à la manipulation du récepteur qui peut s'avérer relativement fragile. De même, le récepteur a tendance a être assez perturbé par les appareils électriques.

(((inter))) La programmation
Le seul travail du logiciel sera d'enregistrer et de décoder la trame. Le programme aura deux grande phase : la première se chargeant de détecter le début de la trame, c'est à dire un espace de deux secondes sans aucun signal. La deuxième phase du programme se charge de stocker les bits de la trame. Comme nous l'avons vu précédemment, celui-ci est un peu particulier. Il existe plusieurs méthodes pour décoder ce signal. Le plus simple est de lancer un ‘timer’ de 150ms, et de lire à la fin de ce temps la valeur que l’on a sur le bus de données, un ‘1’ ou un ‘0’. Cette solution peut se faire facilement en C à l’aide de la fonction Delay() qui stoppe le déroulement du programme pendant un temps déterminé. La solution plus adaptée si vous programmez dans un environnement multitâches, est d'utiliser de la fonction Sleep() qui laisse la main au système d’exploitation pour gérer les autres tâches actives. L'algorithme de décodage d'un bit est le suivant :

(((listing)))
Faire
Lire Signal;
Tant Que Signal=0
Lancer Delay(150ms);
Lire Signal;

(((inter))) Conclusion
Une fois le signal enregistré, le décodage de l'heure et de la date est très facile, ce n'est qu'une simple manipulation de bits. Libre à vous de réaliser un programme complet tournant en tâche de fond de Windows (avec une icône dans le systray par exemple), et qui se chargera de surveiller l'heure du système. Bref, les applications sont innombrables et nous attendons avec impatience vos réalisations.

(((signature)))
Anthony Rabine - arabine@programmationworld.com

(((images)))
elec1.tif : Un exemple de schéma utilisant le port série.
elec2.tif : Voici le protocole utilisé pour coder les '1' et les '0'.
elec3.tif : Le module DCF-77, avec son antenne.
elec4.tif : La zone de réception est assez large.

(((tablo)))
(((légende du tableau : La signification de chaque bit de la trame.)))
Bit
Nom
Description
0..14
-
Réservé
15
R
Bit d'antenne, 1 = seconde antenne utilisée
16
A1
1 = basculement heure été/hiver dans la prochaine heure
17
Z1
1: heure d'été 0: heure d'hiver
18
Z2
Logique contraire de Z1
19
A2
Bit de commutation
20
S
Bit de départ, toujours à 1
21..27
M
Minutes 7 bits (00..59)
28
P1
Bit de parité paire
29..34
H
Heures 6 bits (00..23)
35
P2
Bit de parité paire
36..41
DM
Jour calendaire 6 bits (01..31)
42..44
DW
Jour de la semaine 3 bits (1=lundi..7=dimanche)
45..49
MN
Mois 5 bits (01..12)
50..57
Y
Année 8 bits (00..99)
58
P3
Bit de parité paire

(((encadré)))
(((titre))) Le codage BCD
Ce codage est en fait très simple : les digits d'un nombre sont séparés et codés en binaire à part. Ainsi, nous avons par exemple le chiffre des dizaines codé en binaire suivit du chiffre des unités codé en binaire lui aussi. Mettons que l'on veuille coder 56 minutes en BCD. Il suffit alors de coder d'un côté les dizaines ('5' en binaire donne 101) et de l'autre les unités ('6' en binaire donne 110). Attention cependant à la subtilité de la résolution : le chiffre maximal des unités est 9, qui tient sur 4 bits. Dès lors, '6' sera codé 0110. Au final, nous obtenons bien nos 7 bits pour coder les minutes, soit dans notre exemple 1010110 qui correspond à 56 en décimal. CQFD !
