(((Magazine: PC Team 84)))
(((Rubrique : Team Pratik)))
(((Sous Rubrique : électronique)))

(((titre))) Récepteur infrarouge (2/2)

(((chapo)))
Nous possédons désormais une communication RS232 entre notre microcontrôleur et le PC. Il ne reste plus qu’à écrire le décodage de la trame infrarouge qui constituera le corps du logiciel embarqué.

(((texte)))
Le mois dernier nous avions développé un émulateur de port RS232 bidirectionnel. Nous possédons également un logiciel de test en Visual Basic qui nous permet d’envoyer des informations et de visualiser ce que nous fournit le microcontrôleur. Il s’agit maintenant de développer le corps du système ainsi que la compatibilité avec le plugin de Winamp. La compatibilité sera alors totale avec tous les autres logiciels de contrôle de Windows qui existent. Commençons immédiatement par un petit test. Nous savons que le plugin envoie les caractères ‘I’ et ‘R’ au module et attend les caractères ‘O’ et ‘K’ en signe de réponse. Les deux parties sont alors initialisées et sont prêtes à communiquer. Dans la pratique, la communication ne se fera que du module vers l’ordinateur car il enverra un code correspondant à la touche appuyée sur la télécommande infrarouge. Une fois le code assembleur rédigé, il suffit de brancher le microcontrôleur et de démarrer Winamp… aucun message d’erreur signifiera que notre processeur a parfaitement émulé le comportement du module infrarouge ! La première étape est franchie, voyons maintenant comment programmer le plus important : le décodage infrarouge

(((inter))) Le protocole RC5
Le protocole RC5 est un protocole dédié à la transmission de données infrarouges. Il a été popularisé Philips et depuis la majorité des constructeurs ont adopté ce format, mis à part quelques constructeurs ou appareils exotiques. Ainsi, notre module fonctionnera sans mal avec les télécommandes en votre possession, celle d’une télévision ou d’une chaîne HI-FI. Le protocole RC5 prend la forme d’une trame de données constituée de 14 bits. Le temps bit a une durée normalisée de 1,778 ms et la durée entre deux trames est de 113,78 ms. Cette échelle de temps est malheureusement trop importante pour pouvoir transmettre des informations telle qu’elle dans l’infrarouge. La trame RC5 est donc modulée avec une porteuse dont la fréquence est généralement aux alentours de 36KHz. Ainsi, le rendement s’en trouve largement améliorer et le signal est bien mieux immunisé aux bruits ambiants, essentiellement matérialisés par la lumière artificielle. Nous n’aurons pas à nous occuper de cette partie car le récepteur infrarouge que nous avons choisit dispose en interne de toute l’électronique nécessaire de filtrage. Ainsi, nous récupérons directement la trame RC5 non modulée. Qui plus est, notre récepteur fournit un signal TTL ce qui nous permet de connecter sa sortie directement à une broche du microcontrôleur. Abordons maintenant plus précisément le contenu de cette trame, représentée ci-contre. Les deux premiers bits n’ont pas de signification particulière et servent à signifier le début de la trame. (Bits de Start) Le bit suivant est appelé bit de Répétition : il prévient lorsque le bouton de la télécommande est resté appuyé. Dès lors, point n’est besoin de décoder le reste de la trame, il suffit d’utiliser le code précédent décodé. Les cinq bits suivants représentent les bits d’adresse et les 6 bits restants sont les bits de données. Les adresses servent à spécifier une gamme d’appareils, comme une télévision, un magnétoscope ou une chaîne HI-FI. Ces codes ne font pas partis de la norme RC5 mais constituent une sorte de consensus plus ou moins respecté par les constructeurs. Les données quant à elles représente la touche appuyée, chacune ayant un numéro propre suivant la même logique que les adresses. Un fichier sur le CD-Pro contient quelques adresses et codes usuellement utilisés. L’usage d’une adresse et d’une donnée permet donc d’adresser jusqu’à 32 machines différentes et jusqu’à 64 code pour chaque machine sans interférence. La seule difficulté du processus de décodage se situe surtout dans le décodage des bits. En effet, la trame RC5 utilise un code biphase pour représenter les niveaux logiques de façon à véhiculer l’horloge en même temps que les données. Ce code biphase est illustré sur l’image ci-contre : un ‘0’ est représenté par un front descendant et un ‘1’ par un front montant. Ces fronts se déroulent au milieu du temps bit. Le moment est venu de voir concrètement ce code biphase. Pour cela, il suffit d’alimenter sous 5V le récepteur infrarouge que nous avons choisit, un TSOP 1736 du constructeur Vishay et de regarder la sortie avec un oscilloscope. Les captures que nous avons obtenues sont montrées ci-contre. Au repos, c’est à dire en l’absence de tout signal infrarouge, la sortie est au niveau haut. (5V) La photo suivante montre ce qu’il se passe lorsque l’on a appuyé sur un bouton d’une télécommande. C’est ce signal qui va être envoyé sur une broche du microcontrôleur. Notre travail va donc être de le décoder, afin de trouver deux valeurs : l’adresse et la donnée.

(((inter))) Au boulot !
La trame ressemble quand même diablement à une trame RS232, tout du moins dans l’esprit : le temps bit est fixe dans les deux cas. Nous allons donc procéder à la même stratégie que le mois dernier en utilisant des routines d’attente. Notons que le PIC16F84 possède également un timer qui peut être utile pour notre projet. Il n’y a pas qu’une seule façon de décoder un signal RC5, il faut utiliser l’algorithme et les ressources matérielles qui vous conviennent le mieux. Notre méthode est la suivante : nous allons utiliser le mode d’interruption afin de détecter la présence d’un signal infrarouge. Une fois notre routine d’interruption enclenchée, nous allons décoder la trame RC5, puis envoyer les résultats vers le PC par l’intermédiaire le port série. Le PIC 16F84 possède plusieurs sources d’interruptions matérielles. Ces interruptions sont provoquées par divers évènements apparaissant sur certaines broches du microcontrôleur. Celle qui nous intéresse est de détecter un front descendant, signe de début d’émission d’une trame infra-rouge. Une fois le microcontrôleur initialisé, la routine principale (l’équivalent du main en C) se bornera à boucler indéfiniment.

(((listing)))
REB:
	goto	REB

(((texte)))
Cette routine est l’équivalent d’un while(1) ; en C par exemple. Cette boucle sera interrompue lorsque l’interruption se déclenchera. Nous aurions pu fonctionner par scrutation, c’est à dire lire le signal en provenance du démodulateur infrarouge et attendre un niveau "zéro" avant de continuer. Cette méthode, bien que parfaitement valable dans notre contexte, est cependant à proscrire compte tenu de la nature du signal. Dans des applications plus complexes, le programme principal n'est pas inactif comme ici. Une méthode par scrutation empêcherait donc le programme principal d'effectuer son travail. Notre signal est de nature imprévisible et peut donc survenir à tout instant. Utiliser un mécanisme d'interruption permet alors de rendre notre programme "multitâches". Nous utiliserons la broche RB0 configurée en détection de transition descendante.  Notre routine d'interruption doit être placée à l'adresse 0x04 pour pouvoir être appelée. 

(((listing)))
	org 0x04
Int_RB0:
	…
	; code de décodage RC5 ici
	…
	retfie

(((texte)))
L'interruption sera configurée au début du programme comme à l'accoutumée, avec les registres qui vont bien. Notons enfin un détail important souvent omis : le registre INTCON possède des flags servant à signifier au microcontrôleur que les interruptions ont eu lieu. Il ne faut pas oublier de mettre ces drapeaux à zéro à la fin de la routine d'interruption pour éviter de boucler indéfiniment sur celle-ci. Un programme de test, à terminer vous même mais parfaitement fonctionnel, se trouve sur le CD-Pro 

(((inter))) Conclusion
Maintenant que vous maîtrisez le protocole RC5, pourquoi ne pas améliorer notre module en ajoutant quelques fonctionnalités. Par exemple, il pourrait s'avérer intéressant de le doter d'un émetteur infrarouge piloté par le PC : il sera ainsi possible de contrôler n'importe quel appareil électronique à partir d'un ordinateur, ce qui offre des perspectives très intéressantes.
Notre petite série d'articles prend fin, ainsi que le Team Pratik consacré à l'électronique. Nous espérons que vous avez pris du plaisir à lire cette rubrique, tout autant que nous à l'écrire. Nous vous souhaitons de bien bricoler, et qui sait, nous nous retrouverons pour de nouvelles aventures.

(((signature)))
Anthony Rabine - arabine@programmationworld.com

(((images)))
elec1.tif : La trame prend la forme d'un codage Manchester.
elec2.tif : Au repos, le signal fournit par le module est à 5V.
elec3.tif : Un aperçu de la trame RC5 lors de l'appui d'une touche.
elec4.tif : Détail des bits dans la trame RC5.
elec5.tif : Le schéma final de notre module infra-rouge.
elec6.tif : Le plug-in Winamp vous permet d'enregistrer des actions.
