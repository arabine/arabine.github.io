(((Magazine: PC Team 76)))
(((Rubrique : Team Pratik)))
(((Sous Rubrique : électronique)))

(((titre))) TeamBot (4) – Commande de moteurs

(((chapo)))
Commençons notre robot par lui donner les moyens de se mouvoir. Nous allons étudier sur deux numéros une solution de commande de moteurs à la fois très répandue et extrêmement performante.

(((texte)))
Lors des précédents articles, nous nous sommes intéressés aux outils de développements et à quelques généralités sur la robotique. A présent, nous allons commencer sérieusement notre robot. La tâche qui nous intéresse ce mois ci concerne la partie motrice du robot. Il existe beaucoup de moyens pour faire mouvoir notre engin. Nous souhaitons que celui-ci soit capable de rouler en avant et en arrière, ce qui impose deux sens de rotation. Nous voulons que le robot puisse tourner sur place ; la seule solution est de se munir de deux moteurs. A la manière d'un tank, le robot tournera en faisant fonctionner un moteur dans un sens et l'autre moteur dans le sens inverse. Notre commande doit donc être indépendante pour chaque moteur. Enfin, il peut être salvateur de pouvoir faire varier la vitesse de rotation des moteurs. Ce cahier des charges est alors assez précis : nous prendrons deux moteurs à courant continu. L'électronique du robot sera séparée en plusieurs parties. L'électronique de commande du moteur, que nous verrons le mois prochain, va utiliser des courants beaucoup plus importants que le reste des composants. Cette partie sera appelée "partie puissance" alors que l'électronique faible-courant sera appelée "partie commande". Pour diverses raisons, il est préférable de séparer physiquement ces deux parties. Seuls les signaux de commande seront transmis via des câbles idoines.

(((inter))) La partie puissance
Nous verrons plus en détail cette partie dans le prochain Team Pratik. Néanmoins, il est bon de connaître à peu près ce que nous allons commander. Chaque moteur se verra commandé à l'aide de plusieurs transistors branchés de telle manière à ce qu'ils forment le fameux "pont en H". Ce montage spécial est extrêmement usité pour la commande de moteurs à courant continus car il permet toutes les possibilités. Analysons le schéma fonctionnel présenté ci-contre. La carte de puissance sera composée de deux ponts en H, un pour chaque moteur. Chaque pont en H possède deux entrées de commandes. Un fil sera utiliser pour spécifier le sens de rotation du moteur, le codage sera donc binaire. Le deuxième fil sera utilisé pour commander les transistors de manière à modifier la vitesse de rotation du moteur. Ce signal particulier se nomme MLI pour "Modulation de Largeur d'Impulsion (PWM ou Pulse Width Modulation en anglais). Il est mis en œuvre dans le bloc fonctionnel FS1.1, que nous allons analyser tout de suite.

(((inter))) La MLI
Ce type de signal est, comme nous l'avons dit précédemment, énormément utilisé dans la commande de moteur. On le trouve aussi dans la gestion de capteurs ou d'écrans vidéos, pour faire varier le contraste par exemple et également dans les transmissions par infrarouge. Un signal de type MLI est relativement simple à comprendre. Il s'agit tout simplement d'un signal créneau dont le rapport cyclique est variable. La conséquence est que la valeur moyenne du signal peut être modifiée à volonté. Regardons ensemble le chronogramme présenté ci-contre. Nous avons là deux exemples de MLI. La fréquence du signal est fixe (ici 15kHz) et seul le temps à l'état haut change. On exprime la valeur d'une MLI en pourcentage : le temps passé à l'état haut divisé par la période du signal. Pour le chronogramme du haut, nous avons donc (50/67)*100 soit 75%, et 25% pour le deuxième chronogramme. Il existe plusieurs moyens pour générer un signal de cette forme. Tout d'abord, il est possible de le fabriquer avec des composants analogiques, à base d'amplificateurs opérationnels ou d'oscillateurs de type NE555. Ces méthodes présentent l'avantage d'être peu onéreuses, moins de deux euros en tout et pour tout. Malheureusement leur encombrement sur une carte est important et, plus que tout, leur commande est loin d'être évidente. Rappelons que le cerveau central de notre robot devra envoyer des ordres à la partie commande moteur, d'où la nécessité de pouvoir modifier facilement la valeur de la MLI. Bien que plus chère, notre solution à base de microcontrôleur 16F84 se révèlera fiable, fonctionnelle et parfaitement adaptée à nos besoins.

(((inter))) L'assembleur 16F84
Cela fait déjà quelques numéros que nous parlons de ce processeur. Nous vous invitons donc à vous reporter aux précédents articles, nous considérons à présent que votre chaîne de développement est pleinement fonctionnelle. Penchons-nous un peu sur l'assembleur de cette célèbre famille de Microchip. La première page du datasheet (fourni sur le CD) nous annonce ses caractéristiques alléchantes : seulement 35 instructions à connaître, 1024 mots pour le programme et 68 octets de RAM, le tout cadencé à la fréquence de 20MHz. Attention, le cycle (la fréquence de base) n'est pas de 20MHz mais de 5MHz car la fréquence est divisée en interne. Enfin, une des caractéristiques les plus importantes est l'architecture RISC du processeur. Ainsi, chaque instruction se verra exécutée en un seul cycle d'horloge, soit en 200ns. Ceci n'est pas vrai pour les instructions de branchement qui prennent deux cycles d'horloge. Cette architecture est parfaitement bien adaptée aux microcontrôleurs car le programmeur peut ainsi calculer précisément la durée de ses routines. Commençons par jeter un coup d'œil sur la grammaire de l'assembleur 16F84. Comme la majorité des assembleurs, le code s'écrit dans un fichier texte. Chaque ligne correspond à une instruction, et l'exécution du programme sera totalement séquentielle. L'illustration ci-contre montre un exemple de programme. L'écriture d'un programme en assembleur doit s'écrire de façon rigoureuse. En effet, même si un programme bien indenté est toujours plus facile à relire, l'assembleur impose une place particulière pour chaque élément. Ainsi, on distingue quatre colonnes. La première est réservée aux étiquettes (ou aux labels), la seconde est réservée aux directives et aux mnémoniques, la troisième est utilisée pour les opérandes et enfin la quatrième sert à placer des commentaires sur une seule ligne. Il faut séparer les différentes colonnes à l'aide d'une tabulation pour bien indenter le code source. Les étiquettes servent à marquer une adresse précise dans le programme, pour faire des boucles par exemple. Les directives (en bleu sur l'image) sont destinées à l'assembleur ; elles servent par exemple à indiquer à quelle adresse le code commence. Les mnémoniques (en rouge) constituent le jeu d'instructions compris par le processeur. Les opérandes (quand ils existent) sont constitués de zones mémoires spécifiques. Enfin, les commentaires (optionnels, en vert) permettent de décrire l'opération effectuée. Bien sûr, il est fortement recommandé d'en mettre le plus possible, surtout dans un code assembleur.

(((inter))) Programmation de la MLI
Le 16F84 est malheureusement dépourvu de fonctions embarquées réservées à la génération de MLI. Certains microcontrôleurs en dispose ce qui est très pratique. Il est possible de créer facilement une MLI avec deux timers (des compteurs s'incrémentant à des instants précis) mais là encore notre processeur n'en dispose que d'un seul. Qu'à cela ne tienne, nous allons ruser. Vu que le composant ne fait que ce travail, nous allons utiliser le temps de traitement d'une instruction pour créer des boucles d'attente très précises. Nous avons 200ns par instruction et nous désirons une fréquence ce 15KHz. Il faut donc que notre programme dure 333 cycles par période. Durant cette période, nous avons largement le temps de décoder les ordres, de les mettre en forme et de commander la MLI en conséquence. Nous avons prédéfini cinq valeurs de MLI : 0%, 25%, 50%, 75% et 100%. Notre programme se chargera donc de faire varier le temps à l'état haut selon la valeur de la MLI. Suivez l'organigramme avec le code source situé sur le CD et vous devriez être capable de tout comprendre.

(((inter))) Le mois prochain
Voilà de quoi vous occuper en attendant le prochain article qui portera entièrement sur la carte de puissance. Nous ferons le tour sur certaines théories et nous ferons le lien avec l'article de ce mois-ci pour terminer la chaîne de commande des moteurs. Bien sûr, tous les schémas et les sources seront disponibles pour vous aider.

(((signature)))
Anthony Rabine - arabine@programmationworld.com

(((images)))
elec1.tif : Le principe de notre commande de moteur.
elec2.tif : Deux exemples de signal dit "MLI".
elec3.tif : Un code source bien structuré facilite la relecture !
elec4.tif : L'oscilloscope, un outil indispensable pour l'électronicien.
